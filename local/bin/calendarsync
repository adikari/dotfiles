#!/bin/env bash

# set -euo pipefail

# █░█ ▄▀█ █▀█ █ ▄▀█ █▄▄ █░░ █▀▀ █▀
# ▀▄▀ █▀█ █▀▄ █ █▀█ █▄█ █▄▄ ██▄ ▄█

config="$XDG_CONFIG_HOME/vdirsyncer/config"
lastrun="$XDG_STATE_HOME/vdirsyncer/.lastrun"

# █░█ ▄▀█ █░░ █ █▀▄ ▄▀█ ▀█▀ █ █▀█ █▄░█
# ▀▄▀ █▀█ █▄▄ █ █▄▀ █▀█ ░█░ █ █▄█ █░▀█
 
pgrep -x vdirsyncer >/dev/null && { echo "vdirsyncer is already running." ; exit ;}
ping -q -c 1 1.1.1.1 > /dev/null || { echo "No internet connection detected."; exit ;}


# █▀▀ █░█ █▄░█ █▀▀ ▀█▀ █ █▀█ █▄░█ █▀
# █▀░ █▄█ █░▀█ █▄▄ ░█░ █ █▄█ █░▀█ ▄█

notify() { 
  $HOME/.local/bin/notify "$1" "$2" \
    -a calendar -i calendar -u critical 
}

extract_datetime() {
  local event_data="$1"
  local field="$2"
  local tzid="$3"
  local datetime=""

  local value=$(echo "$event_data" | grep -oP "(?<=${field}).*")
  
  if [[ $value =~ TZID=([^:]+):(.*) ]]; then
    tzid=$(echo "${BASH_REMATCH[1]}" | sed 's/\"//g')
    local dt="${BASH_REMATCH[2]}"
    dt="${dt:0:4}-${dt:4:2}-${dt:6:2}T${dt:9:2}:${dt:11:2}"
  
    datetime=$(TZ="$tzid" date -d "$dt")
  elif [[ $value =~ VALUE=(.*):(.*) ]]; then
    local dt="${BASH_REMATCH[2]}"
    dt="${dt:0:4}-${dt:4:2}-${dt:6:2}"
    
    datetime=$(TZ="$tzid" date -d "$dt")
  else
    local dt="${value:1:4}-${value:5:2}-${value:7:2}T${value:10:2}:${value:12:2}"
    datetime=$(TZ="$tzid" date -d "$dt")
  fi
  
  echo "$datetime"
}

extract_notification_time() {
  local start_date="$1" 
  local trigger="$2" 
  local tzid="$3"
  local rule="$4"
  
  # event has recurring rule
  if [ ! -z "$rule" ]; then
    # RRULE:FREQ=WEEKLY;UNTIL=20231218T003000Z;INTERVAL=1;BYDAY=MO;WKST=SU
    # RRULE:FREQ=WEEKLY;COUNT=52;INTERVAL=1;BYDAY=FR;WKST=MO
    # RRULE:FREQ=WEEKLY;COUNT=30;INTERVAL=2;BYDAY=TH;WKST=MO
    # BYMONTH=1;BYDAY=SU,MO,TU,WE,TH,FR,SA
    # RRULE:FREQ=MONTHLY;BYMONTHDAY=10
    # systemctl --user stop timer-name.timer

    local freq=""
    local until=""
    local interval=""
    local byday=""
    local bymonth=""
    local year=""
    
    while IFS=';' read -ra fields; do
      for field in "${fields[@]}"; do
        IFS='=' read -r key value <<< "$field"
        case "$key" in
          FREQ) freq="$value" ;;
          UNTIL) until="$value" ;;
          INTERVAL) interval="$value" ;;
          BYDAY) byday="$value" ;;
          BYMONTH) bymonth="$value" ;;
          BYYEAR) byyear="$value" ;;
        esac
      done
    done <<< "$rule"

    echo "FREQ: $freq"
    echo "UNTIL: $until"
    echo "INTERVAL: $interval"
    echo "BYDAY: $byday"
    echo "BYMONTH: $bymonth"
    echo "BYYEAR: $byyear"

  # event occurs one time
  else
    local hours=0
    local minutes=0

    if [[ "$trigger" =~ [0-9]+H ]]; then
      hours=$(echo "$trigger" | grep -oP '[0-9]+H' | sed 's/H//')
    fi

    if [[ "$trigger" =~ [0-9]+M ]]; then
      minutes=$(echo "$trigger" | grep -oP '[0-9]+M' | sed 's/M//')
    fi

    notification_time=$(TZ="$tzid" date -d "$start_date - $hours hours - $minutes minutes" +"%s")

    echo "$notification_time"
  fi
}

schedule_notification() {
  local file="$1"
  local alarm_data=""
  local event_data=""
  local in_event=false
  local in_alarm=false

  local summary=()
  local location=()
  local start_date=()
  local trigger=""
  local rule=()

  local tzid="$(grep -m 1 -oP '(?<=TZID:).*' "$file")"

  while IFS= read -r line; do
    if [[ $line == "BEGIN:VEVENT" ]]; then
      in_event=true
      event_data=""
    fi
    
    if [[ $line == "END:VEVENT" ]]; then
      in_event=false
      summary+=("$(echo "$event_data" | grep -oP '(?<=SUMMARY:).*')")
      location+=("$(echo "$event_data" | grep -oP '(?<=LOCATION:).*')")
      start_date+=("$(extract_datetime "$event_data" "DTSTART" "$tzid")")
      rule+=("$(echo "$event_data" | grep -oP '(?<=RRULE:).*')")
    fi
 
    if [[ $in_event == true ]]; then
      event_data+="$line"$'\n'
    fi

    if [[ $line == "BEGIN:VALARM" ]]; then
      in_alarm=true
      alarm_data=""
    fi

    if [[ $line == "END:VALARM" ]]; then
      in_alarm=false
      trigger=$(echo "$alarm_data" | grep -oP '(?<=-P).*')
    fi

    if [[ $in_alarm == true ]]; then
      alarm_data+="$line"$'\n'
    fi
  done < "$file"
   

  now=$(date -d "$(date)" +"%s")
  
  for ((i = 0; i < ${#summary[@]}; i++)); do
    [ -z "${trigger}" ] && continue
    
    extract_notification_time "${start_date[i]}" "${trigger}" "$tzid" "${rule[i]}"
    notification_time=$(extract_notification_time "${start_date[i]}" "${trigger}" "$tzid" "${rule[i]}")

    # if [ ! -z $notification_time ] && [ "$notification_time" -ge "$now" ]; then
    #   local sd="$(date -d "${start_date[i]}" +"%I:%M %p")"
    #   local lc="${location[i]}"
    #   local nt="$(date -d @"$notification_time" +"%I:%M %p %B %d %Y")"
    #
    #   message=""
    #   [[ ! -z "$lc" ]] && message="$lc"
    #   
    #   if [ -z "$message" ]; then
    #     message="$message$sd"
    #   else
    #     message="$message\n$sd"
    #   fi
    #         
    #   # systemd transient timers: https://github.com/lfos/calcurse/issues/285
    #   # https://wiki.archlinux.org/title/Systemd/Timers#Transient_.timer_units
    #   # DayOfWeek Year-Month-Day Hour:Minute:Second
    #   
    #   # systemd-run --user --on-calendar="10sec" \
    #   #   --property=Restart=on-failure --property=RestartSec=5 \
    #   #   -u "Calendar_Reminder_for_$notification_time" \
    #   #   notify "${summary[i]}" "$message"
    # fi
  done
}

syncandnotify() {
  # vdirsyncer sync

  # new=$(find $XDG_DATA_HOME/calendars -type f -name "*.ics" -newer "$lastrun" 2> /dev/null)
  new=$(find $XDG_DATA_HOME/calendars -type f -name "*.icss" 2> /dev/null)

  newcount=$(echo "$new" | sed '/^\s*$/d' | wc -l)
   
  title="title"
  message="message"
  
  case 1 in
    $((newcount > 0)) )
      for file in $new; do
        echo 
        echo "$newcount new event notifications will be scheduled."
        schedule_notification "$file"
      done
      ;;
    *) echo "No new events coming soon." ;;
  esac
}


# █▀ █▄█ █▄░█ █▀▀
# ▄█ ░█░ █░▀█ █▄▄

syncandnotify &
wait

# Create a touch file that indicates the time of the last run of vdirsyncer
# touch "$lastrun"

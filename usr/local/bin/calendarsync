#!/bin/env bash

# set -euo pipefail

# █░█ ▄▀█ █▀█ █ ▄▀█ █▄▄ █░░ █▀▀ █▀
# ▀▄▀ █▀█ █▀▄ █ █▀█ █▄█ █▄▄ ██▄ ▄█

config="${XDG_CONFIG_HOME:-$HOME/.config}/vdirsyncer/config"
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u)/bus
lastrun="${XDG_CONFIG_HOME:-$HOME/.config}/vdirsyncer/.calendarsynclastrun"


# █░█ ▄▀█ █░░ █ █▀▄ ▄▀█ ▀█▀ █ █▀█ █▄░█
# ▀▄▀ █▀█ █▄▄ █ █▄▀ █▀█ ░█░ █ █▄█ █░▀█
 
pgrep -x vdirsyncer >/dev/null && { echo "vdirsyncer is already running." ; exit ;}
ping -q -c 1 1.1.1.1 > /dev/null || { echo "No internet connection detected."; exit ;}

if [ "$(uname)" = "Darwin" ]; then
  notify() { osascript -e "display notification \"$2\" with title \"$1\"" ;} 
else
  command -v notify-send >/dev/null || echo "\`libnotify\` or \`libnotify-send\` should be installed for notifications."

  pgrepoutput="$(pgrep -ax X\(\|org\|wayland\))"
	displays="$(echo "$pgrepoutput" | grep -wo "[0-9]*:[0-9]\+" | sort -u)"
	[ -z "$displays" ] && [ -d /tmp/.X11-unix ] && displays=$(cd /tmp/.X11-unix && for x in X*; do echo ":${x#X}"; done)

  notify() { 
    [ -n "$pgrepoutput" ] && for x in ${displays:-:0}; do
			export DISPLAY="$x"
			notify-send --app-name="calendar" -i calendar "$1" "$2"
		done ;
  }
fi

extract_datetime() {
  local event_data="$1"
  local field="$2"
  local tzid="$3"
  local datetime=""

  local value=$(echo "$event_data" | grep -oP "(?<=${field}).*")
  
  if [[ $value =~ TZID=([^:]+):(.*) ]]; then
    tzid=$(echo "${BASH_REMATCH[1]}" | sed 's/\"//g')
    local dt="${BASH_REMATCH[2]}"
    dt="${dt:0:4}-${dt:4:2}-${dt:6:2}T${dt:9:2}:${dt:11:2}"
  
    datetime=$(TZ="$tzid" date -d "$dt")
  elif [[ $value =~ VALUE=(.*):(.*) ]]; then
    local dt="${BASH_REMATCH[2]}"
    dt="${dt:0:4}-${dt:4:2}-${dt:6:2}"
    
    datetime=$(TZ="$tzid" date -d "$dt")
  else
    local dt="${value:1:4}-${value:5:2}-${value:7:2}T${value:10:2}:${value:12:2}"
    datetime=$(TZ="$tzid" date -d "$dt")
  fi
  
  echo "$datetime"
}

extract_notification_time() {
  local start_date="$1" 
  local trigger="$2" 
  local tzid="$3" 
  local hours=0
  local minutes=0

  if [[ "$trigger" =~ [0-9]+H ]]; then
    hours=$(echo "$trigger" | grep -oP '[0-9]+H' | sed 's/H//')
  fi

  if [[ "$trigger" =~ [0-9]+M ]]; then
    minutes=$(echo "$trigger" | grep -oP '[0-9]+M' | sed 's/M//')
  fi

  notification_time=$(TZ="$tzid" date -d "$start_date - $hours hours - $minutes minutes" +"%s")

  echo "$notification_time"
}

schedule_notification() {
  local file="$1"
  local alarm_data=""
  local event_data=""
  local in_event=false
  local in_alarm=false

  local summary=()
  local location=()
  local start_date=()
  local trigger=""

  local tzid="$(grep -m 1 -oP '(?<=TZID:).*' "$file")"

  while IFS= read -r line; do
    if [[ $line == "BEGIN:VEVENT" ]]; then
      in_event=true
      event_data=""
    fi

    if [[ $line == "END:VEVENT" ]]; then
      in_event=false
       
      summary+=("$(echo "$event_data" | grep -oP '(?<=SUMMARY:).*')")
      location+=("$(echo "$event_data" | grep -oP '(?<=LOCATION:).*')")
      start_date+=("$(extract_datetime "$event_data" "DTSTART" "$tzid")")
    fi
 
    if [[ $in_event == true ]]; then
      event_data+="$line"$'\n'
    fi

    if [[ $line == "BEGIN:VALARM" ]]; then
      in_alarm=true
      alarm_data=""
    fi

    if [[ $line == "END:VALARM" ]]; then
      in_alarm=false
      trigger=$(echo "$alarm_data" | grep -oP '(?<=-P).*')
    fi

    if [[ $in_alarm == true ]]; then
      alarm_data+="$line"$'\n'
    fi
  done < "$file"
   
  now=$(date -d "$(date)" +"%s")
  hour_from_now=$(date -d "+1 hours" +"%s")

  for ((i = 0; i < ${#summary[@]}; i++)); do
    [ -z "${trigger}" ] && continue
    notification_time=$(extract_notification_time "${start_date[i]}" "${trigger}" "$tzid")

    if [ ! -z $notification_time ] && [ "$notification_time" -ge "$now" ] && [ "$notification_time" -le "$hour_from_now" ]; then
      echo "The input date is within the next 1 hours. ========"
    else
      echo "The input date is NOT within the next 1 hours."
    fi
  done

  echo "notify-send -u critical -i calendar 'hello' 'scheduled message'" | at -M "now + 1 minute"
}

syncandnotify() {
  # vdirsyncer sync
  
  new=$(find $HOME/.calendars -type f -name "*.ics" 2> /dev/null)

  newcount=$(echo "$new" | sed '/^\s*$/d' | wc -l)
   
  case 1 in
    $((newcount > 0)) )
      for file in $new; do
        # echo "$newcount new events scheduled soon."
        schedule_notification "$file"
      done
      ;;
    *) echo "No new events coming soon." ;;
  esac
}

syncandnotify &
wait

# Create a touch file that indicates the time of the last run of vdirsyncer
# touch "$lastrun"

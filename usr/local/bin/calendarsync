#!/bin/env bash

set -euo pipefail

# █░█ ▄▀█ █▀█ █ ▄▀█ █▄▄ █░░ █▀▀ █▀
# ▀▄▀ █▀█ █▀▄ █ █▀█ █▄█ █▄▄ ██▄ ▄█

config="${XDG_CONFIG_HOME:-$HOME/.config}/vdirsyncer/config"
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u)/bus
lastrun="${XDG_CONFIG_HOME:-$HOME/.config}/vdirsyncer/.calendarsynclastrun"


# █░█ ▄▀█ █░░ █ █▀▄ ▄▀█ ▀█▀ █ █▀█ █▄░█
# ▀▄▀ █▀█ █▄▄ █ █▄▀ █▀█ ░█░ █ █▄█ █░▀█
 
pgrep -x vdirsyncer >/dev/null && { echo "vdirsyncer is already running." ; exit ;}
ping -q -c 1 1.1.1.1 > /dev/null || { echo "No internet connection detected."; exit ;}

if [ "$(uname)" = "Darwin" ]; then
  notify() { osascript -e "display notification \"$2\" with title \"$1\"" ;} 
else
  command -v notify-send >/dev/null || echo "\`libnotify\` or \`libnotify-send\` should be installed for notifications."

  pgrepoutput="$(pgrep -ax X\(\|org\|wayland\))"
	displays="$(echo "$pgrepoutput" | grep -wo "[0-9]*:[0-9]\+" | sort -u)"
	[ -z "$displays" ] && [ -d /tmp/.X11-unix ] && displays=$(cd /tmp/.X11-unix && for x in X*; do echo ":${x#X}"; done)

  notify() { 
    [ -n "$pgrepoutput" ] && for x in ${displays:-:0}; do
			export DISPLAY="$x"
			notify-send --app-name="calendar" -i calendar "$1" "$2"
		done ;
  }
fi

extract_datetime() {
  local event_data="$1"
  local field="$2"
  local datetime=""

  local value=$(echo "$event_data" | grep -oP "(?<=${field}).*")
  
  if [[ $value =~ TZID=([^:]+):(.*) ]]; then
    local tzid=$(echo "${BASH_REMATCH[1]}" | sed 's/\"//g')
    local dt="${BASH_REMATCH[2]}"
    dt="${dt:0:4}-${dt:4:2}-${dt:6:2}T${dt:9:2}:${dt:11:2}"
  
    datetime=$(TZ="$tzid" date -d "$dt")
  else
    # No timezone information, assume UTC
    datetime=$(date -u -d "$value")
  fi
  
  echo "$datetime"
}

extract_notification_time() {
  local start_date="$1" 
  local trigger="$2" 
  local hours=0
  local minutes=0

  if [[ "$trigger" =~ [0-9]+H ]]; then
    hours=$(echo "$trigger" | grep -oP '[0-9]+H' | sed 's/H//')
  fi

  if [[ "$trigger" =~ [0-9]+M ]]; then
    minutes=$(echo "$trigger" | grep -oP '[0-9]+M' | sed 's/M//')
  fi

  notification_time=$(TZ="Australia/Melbourne" date -d "$start_date - $hours hours - $minutes minutes")

  echo "$notification_time"
}

schedule_notification() {
  local file="$1"
  local alarm_data=""
  local event_data=""
  local in_event=false
  local in_alarm=false

  local summary=()
  local location=()
  local start_date=()
  local end_date=()
  local trigger=""

  while IFS= read -r line; do
    if [[ $line == "BEGIN:VEVENT" ]]; then
      in_event=true
      event_data=""
    fi

    if [[ $line == "END:VEVENT" ]]; then
      in_event=false
       
      summary+=("$(echo "$event_data" | grep -oP '(?<=SUMMARY:).*')")
      location+=("$(echo "$event_data" | grep -oP '(?<=LOCATION:).*')")
      start_date+=("$(extract_datetime "$event_data" "DTSTART")")
      end_date+=("$(extract_datetime "$event_data" "DTEND")")
    fi
 
    if [[ $in_event == true ]]; then
      event_data+="$line"$'\n'
    fi

    if [[ $line == "BEGIN:VALARM" ]]; then
      in_alarm=true
      alarm_data=""
    fi

    if [[ $line == "END:VALARM" ]]; then
      in_alarm=false
      trigger=$(echo "$alarm_data" | grep -oP '(?<=-P).*')
    fi

    if [[ $in_alarm == true ]]; then
      alarm_data+="$line"$'\n'
    fi
  done < "$file"
   
  for ((i = 0; i < ${#summary[@]}; i++)); do
    [ -z "${trigger}" ] && continue
    
    notification_time=$(extract_notification_time "${start_date[i]}" "${trigger}")
    echo "start date" ${start_date[i]}
    echo "notification" $notification_time
  done
}

syncandnotify() {
  # vdirsyncer sync
  
  new=$(find $HOME/.calendars -type f -name "*.icss" 2> /dev/null)

  newcount=$(echo "$new" | sed '/^\s*$/d' | wc -l)
   
  case 1 in
    $((newcount > 0)) )
      for file in $new; do
        echo "$newcount new events scheduled soon."
        schedule_notification "$file"
      done
      ;;
    *) echo "No new events coming soon." ;;
  esac
}

syncandnotify &
wait

# Create a touch file that indicates the time of the last run of vdirsyncer
# touch "$lastrun"
